{"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/learnwithromain\/parentchildtutorial"]}],"kind":"project","hierarchy":{"modules":[{"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture\/Composing-features","projects":[{"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial","sections":[{"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Creating-a-parent-view-with-a-child-view","kind":"task"},{"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Communication-from-Child-to-Parent","kind":"task"},{"kind":"task","reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Communication-from-Parent-to-Child"}]}]}],"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture","paths":[["doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture","doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture\/$volume","doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture\/Composing-features"]]},"metadata":{"categoryPathComponent":"RefineComposableArchitecture","category":"The Composable Architecture","title":"Building a Parent-Child Relationship","role":"project"},"identifier":{"url":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial","interfaceLanguage":"swift"},"sections":[{"title":"Building a Parent-Child Relationship","kind":"hero","chapter":"Composing features","content":[{"inlineContent":[{"type":"text","text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them."}],"type":"paragraph"}],"estimatedTimeInMinutes":15},{"kind":"tasks","tasks":[{"contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We will compose the parent and child features together."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a practice that enables us to build complex functionality by combining smaller, more manageable features."}]}],"mediaPosition":"trailing"}],"title":"Creating a parent view with a child view","stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a new file named "},{"code":"ChildFeature.swift","type":"codeVoice"},{"type":"text","text":". This feature contains decrement and increment buttons with a label specifying the current value, which can be tapped to reset its value to zero."}]}],"code":"01-01-01-code-0001.swift","runtimePreview":"01-01-01-image-0001.png","media":null,"type":"step"},{"type":"step","media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Create a new file named ","type":"text"},{"code":"ParentFeature.swift","type":"codeVoice"},{"text":" with some basic scaffolding in place.","type":"text"}]}],"runtimePreview":null,"caption":[{"content":[{"inlineContent":[{"type":"text","text":"Since TCA 1.8, the @Reducer macro automatically fulfills the reducer requirements. The parent reducer does not have any state, actions, or logic yet, so we can omit them."}],"type":"paragraph"}],"type":"aside","name":"Note","style":"note"}],"code":"01-01-01-code-0002.swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s compose the features together at the reducer level."}]},{"runtimePreview":null,"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add State and Action to the reducer. The parent reducer will hold the state and actions of the child reducer."}]}],"code":"01-01-01-code-0003.swift","media":null},{"runtimePreview":null,"caption":[{"style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"It exposes child state and actions to the parent reducer."}],"type":"paragraph"}],"type":"aside"}],"type":"step","media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Next, we need to implement the body of the reducer. To compose the child reducer within the parent reducer, we use the ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/scope"},{"text":" reducer. This allows us to focus on a sub-domain of the parent feature and run a child reducer on that sub-domain.","type":"text"}]}],"code":"01-01-01-code-0004.swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s compose the features together at the view level."}]},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Use the ","type":"text"},{"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/store\/scope(state:action:)-90255","isActive":true,"type":"reference"},{"text":" method on the store to derive a child store focused in on just the child domain.","type":"text"}]}],"media":null,"runtimePreview":"01-01-01-image-0005.png","code":"01-01-01-code-0005.swift","caption":[]},{"inlineContent":[{"type":"text","text":"The two views are now composed together:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The parent state consists of its own values and the child state."}]}]},{"content":[{"inlineContent":[{"text":"The parent reducer receives every action dispatched by the child reducer.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"The child store is a scoped variant of the parent store.","type":"text"}],"type":"paragraph"}]}]}],"anchor":"Creating-a-parent-view-with-a-child-view"},{"anchor":"Communication-from-Child-to-Parent","contentSection":[{"content":[{"inlineContent":[{"type":"text","text":"Parent-child communication refers to the exchange of information or triggering of actions between hierarchical views."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The terms “parent” and “child” are used to describe the relationship between different components or modules within an app."}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"title":"Communication from Child to Parent","stepsSection":[{"type":"paragraph","inlineContent":[{"text":"Let’s see how the child should communicate with a parent feature.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the parent needs to respond to events happening in the child, it can simply listen to the corresponding actions that arrive in the reducer."}]},{"code":"01-01-02-code-0001.swift","runtimePreview":"01-01-02-video-0001.mp4","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We just need to add an action to listen to from the child reducer."}]}],"type":"step","caption":[{"style":"note","name":"Note","type":"aside","content":[{"inlineContent":[{"type":"text","text":"This is possible thanks to the "},{"type":"reference","identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/scope","isActive":true},{"text":" reducer.","type":"text"}],"type":"paragraph"}]}],"media":null},{"type":"paragraph","inlineContent":[{"text":"There is no need to add extra code to be aware of the current state of the child reducer since the parent reducer has a reference to it.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"As we can see, TCA follows a strict unidirectional data flow pattern (state flows from parent to child, events flows from child to parent…) which enforces immutability and a single source of truth. As the app grows, it simplifies handling complex interactions and state management.","type":"text"}]}]},{"stepsSection":[{"inlineContent":[{"type":"text","text":"If the parent wants to execute some logic within the child by reusing one of its actions, it should be done by directly invoking the child reducer."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To send an action from the parent to the child, invoke the child reducer using a reduce method. For example, if we want to ensure that the count never goes lower than zero, we can reuse a reset action."}]}],"caption":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Find more details on sharing logic in child features "},{"type":"reference","identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/performance\/#Sharing-logic-in-child-features","isActive":true},{"type":"text","text":"."}]}],"style":"note","type":"aside","name":"Note"}],"code":"01-01-03-code-0001.swift","media":null,"runtimePreview":"01-01-03-video-0001.mp4","type":"step"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the parent needs to update the state of the child without any shared logic available, we can create an extension on the child state."}]},{"content":[{"inlineContent":[{"type":"text","text":"We implement a mutating method where we update any necessary state and return an action. For example, let’s say we want to set the initial count to 10."}],"type":"paragraph"}],"media":null,"runtimePreview":"01-01-03-video-0002.mov","caption":[{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It is better to use a mutating method rather than updating the child state directly from the parent reducer, as a new child reducer would be recreated, potentially leading to lost states and increased complexity."}]}],"name":"Note"}],"type":"step","code":"01-01-03-code-0002.swift"}],"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We’ve seen how the child communicates with its parent. The same approach cannot be followed from parent to child."}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"anchor":"Communication-from-Parent-to-Child","title":"Communication from Parent to Child"}]}],"references":{"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial#Communication-from-Parent-to-Child":{"type":"section","abstract":[{"text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them.","type":"text"}],"url":"\/tutorials\/learnwithromain\/parentchildtutorial#Communication-from-Parent-to-Child","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Communication-from-Parent-to-Child","title":"Communication from Parent to Child"},"01-01-01-code-0005.swift":{"fileType":"swift","fileName":"ParentFeature.swift","highlights":[{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36}],"syntax":"swift","content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            \/\/ Core logic of the app feature","            return .none","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","        }","    }","}",""],"identifier":"01-01-01-code-0005.swift","type":"file"},"01-01-01-code-0004.swift":{"type":"file","fileName":"ParentFeature.swift","highlights":[{"line":16},{"line":17},{"line":18},{"line":19}],"syntax":"swift","content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            \/\/ Core logic of the app feature","            return .none","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        EmptyView()","    }","}",""],"identifier":"01-01-01-code-0004.swift","fileType":"swift"},"01-01-01-code-0002.swift":{"fileType":"swift","fileName":"ParentFeature.swift","highlights":[],"syntax":"swift","content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        EmptyView()","    }","}",""],"identifier":"01-01-01-code-0002.swift","type":"file"},"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial#Communication-from-Child-to-Parent":{"type":"section","abstract":[{"text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them.","type":"text"}],"url":"\/tutorials\/learnwithromain\/parentchildtutorial#Communication-from-Child-to-Parent","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Communication-from-Child-to-Parent","title":"Communication from Child to Parent"},"01-01-01-image-0001.png":{"type":"image","variants":[{"url":"\/images\/01-01-01-image-0001.png","traits":["1x","light"]}],"alt":"iOS application showing a text view in the center displaying a 0 and two buttons positioned on each side of it, one for decrementing the count and one for incrementing.","identifier":"01-01-01-image-0001.png"},"doc://com.learnwithromain.learnwithromain/tutorials/RefineComposableArchitecture/Composing-features":{"type":"topic","abstract":[],"url":"\/tutorials\/refinecomposablearchitecture\/composing-features","kind":"article","role":"article","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture\/Composing-features","title":"Composing features"},"01-01-02-code-0001.swift":{"fileType":"swift","fileName":"ParentFeature.swift","highlights":[{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27}],"syntax":"swift","content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            switch action {","            case .child(.incrementButtonTapped):","                \/\/ We listen to the incrementButtonTapped child action","                return .none","            default:","                return .none","            }","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","        }","    }","}",""],"identifier":"01-01-02-code-0001.swift","type":"file"},"https://pointfreeco.github.io/swift-composable-architecture/main/documentation/composablearchitecture/scope":{"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/scope","title":" Scope","type":"link","titleInlineContent":[{"type":"text","text":" Scope"}],"url":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/scope"},"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial":{"title":"Building a Parent-Child Relationship","type":"topic","role":"project","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial","url":"\/tutorials\/learnwithromain\/parentchildtutorial","estimatedTime":"15min","abstract":[{"type":"text","text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them."}],"kind":"project"},"01-01-01-code-0001.swift":{"fileType":"swift","fileName":"ChildFeature.swift","highlights":[],"syntax":"swift","content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ChildFeature {","    @ObservableState","    struct State {","        var count: Int","    }","    ","    enum Action {","        case decrementButtonTapped","        case incrementButtonTapped","        case resetTapped","    }","    ","    var body: some ReducerOf<Self> {","        Reduce { state, action in","            switch action {","            case .incrementButtonTapped:","                state.count += 1","                return .none","            case .decrementButtonTapped:","                state.count -= 1","                return .none","            case .resetTapped:","                state.count = 0","                return .none","            }","        }","    }","}","","struct ChildView: View {","    let store: StoreOf<ChildFeature>","    ","    var body: some View {","        HStack {","            Button(\"-\") {","                store.send(.decrementButtonTapped)","            }","            .font(.largeTitle)","            .padding()","            .background(Color.black.opacity(0.1))","            .cornerRadius(10)","            Text(String(store.count))","                .font(.largeTitle)","                .padding()","                .background(Color.black.opacity(0.1))","                .cornerRadius(10)","                .onTapGesture {","                    store.send(.resetTapped)","                }","            Button(\"+\") {","                store.send(.incrementButtonTapped)","            }","            .font(.largeTitle)","            .padding()","            .background(Color.black.opacity(0.1))","            .cornerRadius(10)","        }","    }","}"],"identifier":"01-01-01-code-0001.swift","type":"file"},"01-01-03-video-0001.mp4":{"alt":null,"poster":null,"type":"video","identifier":"01-01-03-video-0001.mp4","variants":[{"url":"\/videos\/01-01-03-video-0001.mp4","traits":["1x","light"]}]},"01-01-03-code-0002.swift":{"syntax":"swift","highlights":[{"line":13},{"line":23},{"line":24},{"line":25},{"line":26},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":50},{"line":51},{"line":52}],"type":"file","content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","        case onAppear","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            switch action {","            case .onAppear:","                return state.child","                    .updateNumber(with: 10)","                    .map(Action.child)","            default:","                return .none","            }","        }","    }","}","","extension ChildFeature.State {","    mutating func updateNumber(with count: Int) -> Effect<ChildFeature.Action> {","        self.count = count","        return .none","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","            .onAppear {","                store.send(.onAppear)","            }","        }","    }","}"],"identifier":"01-01-03-code-0002.swift","fileName":"ParentFeature.swift","fileType":"swift"},"01-01-03-code-0001.swift":{"syntax":"swift","highlights":[{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30}],"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            switch action {","            case .child(.decrementButtonTapped):","                guard state.child.count < 0 else { return .none }","                ","                return ChildFeature()","                    .reduce(","                        into: &state.child,","                        action: .resetTapped","                    )","                    .map(Action.child)","            default:","                return .none","            }","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","        }","    }","}"],"type":"file","fileName":"ParentFeature.swift","identifier":"01-01-03-code-0001.swift","fileType":"swift"},"01-01-02-video-0001.mp4":{"type":"video","variants":[{"url":"\/videos\/01-01-02-video-0001.mp4","traits":["1x","light"]}],"alt":null,"identifier":"01-01-02-video-0001.mp4","poster":null},"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial#Creating-a-parent-view-with-a-child-view":{"url":"\/tutorials\/learnwithromain\/parentchildtutorial#Creating-a-parent-view-with-a-child-view","title":"Creating a parent view with a child view","type":"section","abstract":[{"type":"text","text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them."}],"kind":"section","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Creating-a-parent-view-with-a-child-view","role":"pseudoSymbol"},"01-01-01-code-0003.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Reduce { state, action in","            \/\/ Core logic of the app feature","            return .none","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        EmptyView()","    }","}",""],"syntax":"swift","highlights":[{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21}],"identifier":"01-01-01-code-0003.swift","fileName":"ParentFeature.swift","type":"file","fileType":"swift"},"01-01-03-video-0002.mov":{"alt":null,"poster":null,"type":"video","identifier":"01-01-03-video-0002.mov","variants":[{"url":"\/videos\/01-01-03-video-0002.mov","traits":["1x","light"]}]},"https://pointfreeco.github.io/swift-composable-architecture/main/documentation/composablearchitecture/performance/#Sharing-logic-in-child-features":{"type":"link","url":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/performance\/#Sharing-logic-in-child-features","identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/performance\/#Sharing-logic-in-child-features","title":"here","titleInlineContent":[{"text":"here","type":"text"}]},"https://pointfreeco.github.io/swift-composable-architecture/main/documentation/composablearchitecture/store/scope(state:action:)-90255":{"titleInlineContent":[{"text":" scope(state:action:)","type":"text"}],"url":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/store\/scope(state:action:)-90255","type":"link","identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/store\/scope(state:action:)-90255","title":" scope(state:action:)"},"01-01-01-image-0005.png":{"type":"image","variants":[{"url":"\/images\/01-01-01-image-0005.png","traits":["1x","light"]}],"alt":"iOS application showing a text view in the center displaying a 0 and two buttons positioned on each side of it, one for decrementing the count and one for incrementing.","identifier":"01-01-01-image-0005.png"},"doc://com.learnwithromain.learnwithromain/tutorials/RefineComposableArchitecture":{"kind":"overview","abstract":[{"text":"This interactive tutorial aims to provide best practices for building a project with TCA. It brings together information to help developers apply TCA principles effectively in their projects.","type":"text"}],"type":"topic","role":"overview","url":"\/tutorials\/refinecomposablearchitecture","title":"Refine the Composable Architecture","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture"}}}