{"sections":[{"chapter":"Composing features","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them."}]}],"estimatedTimeInMinutes":20,"kind":"hero","title":"Building a Parent-Child Relationship"},{"tasks":[{"contentSection":[{"mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We will compose the parent and child features together."}]},{"type":"paragraph","inlineContent":[{"text":"This is a practice that enables us to build complex functionality by combining smaller, more manageable features.","type":"text"}]}],"kind":"contentAndMedia"}],"title":"Creating a parent view with a child view","stepsSection":[{"runtimePreview":"01-01-01-image-0001.png","content":[{"inlineContent":[{"text":"Create a new file named ","type":"text"},{"type":"codeVoice","code":"ChildFeature.swift"},{"text":". This feature contains decrement and increment buttons with a label specifying the current value, which can be tapped to reset its value to zero.","type":"text"}],"type":"paragraph"}],"caption":[],"type":"step","media":null,"code":"01-01-01-code-0001.swift"},{"runtimePreview":null,"media":null,"type":"step","caption":[{"type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"Since TCA 1.8, the @Reducer macro automatically fulfills the reducer requirements. The parent reducer does not have any state, actions, or logic yet, so we can omit them."}],"type":"paragraph"}],"name":"Note"}],"code":"01-01-01-code-0002.swift","content":[{"inlineContent":[{"text":"Create a new file named ","type":"text"},{"code":"ParentFeature.swift","type":"codeVoice"},{"text":" with some basic scaffolding in place.","type":"text"}],"type":"paragraph"}]},{"inlineContent":[{"text":"Let’s compose the features together at the reducer level.","type":"text"}],"type":"paragraph"},{"caption":[],"type":"step","media":null,"content":[{"inlineContent":[{"text":"Add State and Action to the reducer. The parent reducer will hold the state and actions of the child reducer.","type":"text"}],"type":"paragraph"}],"code":"01-01-01-code-0003.swift","runtimePreview":null},{"media":null,"runtimePreview":null,"type":"step","caption":[{"style":"note","type":"aside","content":[{"inlineContent":[{"text":"It exposes child state and actions to the parent reducer.","type":"text"}],"type":"paragraph"}],"name":"Note"}],"code":"01-01-01-code-0004.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Next, we need to implement the body of the reducer. To compose the child reducer within the parent reducer, we use the ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/scope"},{"type":"text","text":" reducer. This allows us to focus on a sub-domain of the parent feature and run a child reducer on that sub-domain."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s compose the features together at the view level."}]},{"caption":[],"code":"01-01-01-code-0005.swift","media":null,"runtimePreview":"01-01-01-image-0005.png","type":"step","content":[{"inlineContent":[{"type":"text","text":"Use the "},{"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/store\/scope(state:action:)-90255","isActive":true,"type":"reference"},{"text":" method on the store to derive a child store focused in on just the child domain.","type":"text"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The two views are now composed together:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The parent state consists of its own values and the child state."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The parent reducer receives every action dispatched by the child reducer."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The child store is a scoped variant of the parent store."}]}]}],"type":"unorderedList"}],"anchor":"Creating-a-parent-view-with-a-child-view"},{"stepsSection":[{"inlineContent":[{"text":"Let’s see how the child should communicate with a parent feature.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If the parent needs to respond to events happening in the child, it can simply listen to the corresponding actions that arrive in the reducer."}],"type":"paragraph"},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"We just need to add an action to listen to from the child reducer.","type":"text"}]}],"runtimePreview":"01-01-02-video-0001.mp4","caption":[{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This is possible thanks to the "},{"type":"reference","identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/scope","isActive":true},{"text":" reducer.","type":"text"}]}],"type":"aside"}],"media":null,"code":"01-01-02-code-0001.swift"},{"inlineContent":[{"text":"There is no need to add extra code to be aware of the current state of the child reducer since the parent reducer has a reference to it.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"As we can see, TCA follows a strict unidirectional data flow pattern (state flows from parent to child, events flows from child to parent…) which enforces immutability and a single source of truth. As the app grows, it simplifies handling complex interactions and state management.","type":"text"}]}],"contentSection":[{"content":[{"inlineContent":[{"text":"Parent-child communication refers to the exchange of information or triggering of actions between hierarchical views.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The terms “parent” and “child” are used to describe the relationship between different components or modules within an app."}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"anchor":"Communication-from-Child-to-Parent","title":"Communication from Child to Parent"},{"title":"Communication from Parent to Child","anchor":"Communication-from-Parent-to-Child","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"We’ve seen how the child communicates with its parent. The same approach cannot be followed from parent to child.","type":"text"}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"stepsSection":[{"inlineContent":[{"type":"text","text":"If the parent wants to execute some logic within the child by reusing one of its actions, it should be done by directly invoking the child reducer."}],"type":"paragraph"},{"code":"01-01-03-code-0001.swift","runtimePreview":"01-01-03-video-0001.mp4","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To send an action from the parent to the child, invoke the child reducer using a reduce method. For example, if we want to ensure that the count never goes lower than zero, we can reuse a reset action."}]}],"type":"step","caption":[{"type":"aside","content":[{"inlineContent":[{"type":"text","text":"Find more details on sharing logic in child features "},{"type":"reference","identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/performance\/#Sharing-logic-in-child-features","isActive":true},{"text":".","type":"text"}],"type":"paragraph"}],"name":"Note","style":"note"}],"media":null},{"inlineContent":[{"text":"If the parent needs to update the state of the child without any shared logic available, we can create an extension on the child state.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"We implement a mutating method where we update any necessary state and return an action. For example, let’s say we want to set the initial count to 10.","type":"text"}]}],"caption":[{"content":[{"inlineContent":[{"type":"text","text":"It is better to use a mutating method rather than updating the child state directly from the parent reducer, as a new child reducer would be recreated, potentially leading to lost states and increased complexity."}],"type":"paragraph"}],"name":"Note","type":"aside","style":"note"}],"media":null,"type":"step","code":"01-01-03-code-0002.swift","runtimePreview":"01-01-03-video-0002.mov"}]},{"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"TCA facilitates unit testing by enabling isolated testing of components with well-defined inputs and outputs. This is achieved thanks to the reducers, which separate business logic from UI."}]},{"inlineContent":[{"type":"text","text":"Reducers are functions that take the current state and an action as input and return a new state as output."}],"type":"paragraph"}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"stepsSection":[{"type":"paragraph","inlineContent":[{"text":"Before we perform any assertions, the State must be ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}]},{"runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"In order to assert against sent actions from the parent store, its "},{"type":"codeVoice","code":"State"},{"text":" must be ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"caption":[],"code":"01-01-04-code-0001.swift"},{"media":null,"type":"step","caption":[],"runtimePreview":null,"code":"01-01-04-code-0002.swift","content":[{"inlineContent":[{"type":"text","text":"In order to assert against sent actions from the child store, its "},{"code":"State","type":"codeVoice"},{"text":" must also be ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":".","type":"text"}],"type":"paragraph"}]},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s begin by creating a "},{"type":"codeVoice","code":"ParentFeatureTests.swift"},{"type":"text","text":" file with some basic scaffolding set up for the test."}]}],"code":"01-01-04-code-0003.swift","media":null,"type":"step","runtimePreview":null},{"type":"step","code":"01-01-04-code-0004.swift","caption":[{"type":"aside","content":[{"inlineContent":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"TestStore"},{"text":" provides a controlled environment for testing components of the architecture, such as reducers and effects.","type":"text"}],"type":"paragraph"}],"style":"note","name":"Note"}],"media":null,"content":[{"inlineContent":[{"type":"text","text":"Let’s first set up our test store and then assert how the state changes when the "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" action is sent to the store."}],"type":"paragraph"}],"runtimePreview":null},{"code":"01-01-04-code-0005.swift","caption":[{"style":"note","name":"Note","type":"aside","content":[{"inlineContent":[{"text":"Since TCA 1.9, we can use case key paths with the send method. This simplifies integration-style tests that send deeply-nested actions and aligns with the syntax of the receive method. Find more details ","type":"text"},{"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/1.9.0\/documentation\/composablearchitecture\/migratingto1.9#Sending-test-store-actions","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"}]}],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Finally, we’ll ensure the count value is correct by testing the increment, decrement, and reset behaviors of our child feature.","type":"text"}]}],"media":null,"runtimePreview":null}],"title":"Testing the communication","anchor":"Testing-the-communication"}],"kind":"tasks"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial"},"schemaVersion":{"minor":3,"major":0,"patch":0},"kind":"project","metadata":{"categoryPathComponent":"RefineComposableArchitecture","category":"The Composable Architecture","role":"project","title":"Building a Parent-Child Relationship"},"hierarchy":{"paths":[["doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture","doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture\/$volume","doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture\/Composing-features"]],"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture","modules":[{"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture\/Composing-features","projects":[{"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial","sections":[{"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Creating-a-parent-view-with-a-child-view","kind":"task"},{"kind":"task","reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Communication-from-Child-to-Parent"},{"reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Communication-from-Parent-to-Child","kind":"task"},{"kind":"task","reference":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Testing-the-communication"}]}]}]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/learnwithromain\/parentchildtutorial"]}],"references":{"doc://com.learnwithromain.learnwithromain/tutorials/RefineComposableArchitecture/Composing-features":{"title":"Composing features","kind":"article","url":"\/tutorials\/refinecomposablearchitecture\/composing-features","abstract":[],"identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture\/Composing-features","type":"topic","role":"article"},"01-01-02-video-0001.mp4":{"identifier":"01-01-02-video-0001.mp4","poster":null,"alt":null,"type":"video","variants":[{"url":"\/videos\/01-01-02-video-0001.mp4","traits":["1x","light"]}]},"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial":{"title":"Building a Parent-Child Relationship","kind":"project","estimatedTime":"20min","type":"topic","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial","abstract":[{"text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them.","type":"text"}],"role":"project","url":"\/tutorials\/learnwithromain\/parentchildtutorial"},"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial#Testing-the-communication":{"abstract":[{"text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them.","type":"text"}],"role":"pseudoSymbol","type":"section","kind":"section","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Testing-the-communication","url":"\/tutorials\/learnwithromain\/parentchildtutorial#Testing-the-communication","title":"Testing the communication"},"https://pointfreeco.github.io/swift-composable-architecture/main/documentation/composablearchitecture/performance/#Sharing-logic-in-child-features":{"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/performance\/#Sharing-logic-in-child-features","title":"here","url":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/performance\/#Sharing-logic-in-child-features","type":"link","titleInlineContent":[{"type":"text","text":"here"}]},"https://pointfreeco.github.io/swift-composable-architecture/main/documentation/composablearchitecture/store/scope(state:action:)-90255":{"type":"link","url":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/store\/scope(state:action:)-90255","title":" scope(state:action:)","titleInlineContent":[{"text":" scope(state:action:)","type":"text"}],"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/store\/scope(state:action:)-90255"},"01-01-01-code-0003.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Reduce { state, action in","            \/\/ Core logic of the app feature","            return .none","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        EmptyView()","    }","}",""],"fileName":"ParentFeature.swift","syntax":"swift","highlights":[{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21}],"type":"file","identifier":"01-01-01-code-0003.swift","fileType":"swift"},"01-01-03-code-0002.swift":{"identifier":"01-01-03-code-0002.swift","fileType":"swift","type":"file","syntax":"swift","highlights":[{"line":13},{"line":23},{"line":24},{"line":25},{"line":26},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":50},{"line":51},{"line":52}],"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","        case onAppear","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            switch action {","            case .onAppear:","                return state.child","                    .updateNumber(with: 10)","                    .map(Action.child)","            default:","                return .none","            }","        }","    }","}","","extension ChildFeature.State {","    mutating func updateNumber(with count: Int) -> Effect<ChildFeature.Action> {","        self.count = count","        return .none","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","            .onAppear {","                store.send(.onAppear)","            }","        }","    }","}"],"fileName":"ParentFeature.swift"},"01-01-04-code-0002.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ChildFeature {","    @ObservableState","    struct State: Equatable {","        var count: Int","    }","    ","    enum Action {","        case decrementButtonTapped","        case incrementButtonTapped","        case resetTapped","    }","    ","    var body: some ReducerOf<Self> {","        Reduce { state, action in","            switch action {","            case .incrementButtonTapped:","                state.count += 1","                return .none","            case .decrementButtonTapped:","                state.count -= 1","                return .none","            case .resetTapped:","                state.count = 0","                return .none","            }","        }","    }","}","","struct ChildView: View {","    let store: StoreOf<ChildFeature>","    ","    var body: some View {","        HStack {","            Button(\"-\") {","                store.send(.decrementButtonTapped)","            }","            .font(.largeTitle)","            .padding()","            .background(Color.black.opacity(0.1))","            .cornerRadius(10)","            Text(String(store.count))","                .font(.largeTitle)","                .padding()","                .background(Color.black.opacity(0.1))","                .cornerRadius(10)","                .onTapGesture {","                    store.send(.resetTapped)","                }","            Button(\"+\") {","                store.send(.incrementButtonTapped)","            }","            .font(.largeTitle)","            .padding()","            .background(Color.black.opacity(0.1))","            .cornerRadius(10)","        }","    }","}"],"type":"file","fileName":"ChildFeature.swift","syntax":"swift","highlights":[{"line":7}],"identifier":"01-01-04-code-0002.swift","fileType":"swift"},"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial#Communication-from-Parent-to-Child":{"abstract":[{"text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them.","type":"text"}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Communication-from-Parent-to-Child","title":"Communication from Parent to Child","url":"\/tutorials\/learnwithromain\/parentchildtutorial#Communication-from-Parent-to-Child"},"https://pointfreeco.github.io/swift-composable-architecture/1.9.0/documentation/composablearchitecture/migratingto1.9#Sending-test-store-actions":{"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/1.9.0\/documentation\/composablearchitecture\/migratingto1.9#Sending-test-store-actions","titleInlineContent":[{"type":"text","text":"here"}],"url":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/1.9.0\/documentation\/composablearchitecture\/migratingto1.9#Sending-test-store-actions","title":"here","type":"link"},"01-01-01-image-0001.png":{"identifier":"01-01-01-image-0001.png","alt":"iOS application showing a text view in the center displaying a 0 and two buttons positioned on each side of it, one for decrementing the count and one for incrementing.","type":"image","variants":[{"url":"\/images\/01-01-01-image-0001.png","traits":["1x","light"]}]},"01-01-04-code-0003.swift":{"content":["import ComposableArchitecture","import XCTest","","@MainActor","final class ParentFeatureTests: XCTestCase {","    func testParentFeature() async {","","    }","}"],"type":"file","fileName":"ParentFeatureTests.swift","syntax":"swift","highlights":[],"identifier":"01-01-04-code-0003.swift","fileType":"swift"},"01-01-03-video-0001.mp4":{"identifier":"01-01-03-video-0001.mp4","poster":null,"alt":null,"type":"video","variants":[{"url":"\/videos\/01-01-03-video-0001.mp4","traits":["1x","light"]}]},"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial#Communication-from-Child-to-Parent":{"abstract":[{"text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them.","type":"text"}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Communication-from-Child-to-Parent","url":"\/tutorials\/learnwithromain\/parentchildtutorial#Communication-from-Child-to-Parent","title":"Communication from Child to Parent"},"01-01-01-code-0005.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            \/\/ Core logic of the app feature","            return .none","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","        }","    }","}",""],"type":"file","fileName":"ParentFeature.swift","syntax":"swift","highlights":[{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36}],"identifier":"01-01-01-code-0005.swift","fileType":"swift"},"01-01-01-code-0004.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            \/\/ Core logic of the app feature","            return .none","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        EmptyView()","    }","}",""],"type":"file","fileName":"ParentFeature.swift","syntax":"swift","highlights":[{"line":16},{"line":17},{"line":18},{"line":19}],"identifier":"01-01-01-code-0004.swift","fileType":"swift"},"01-01-04-code-0005.swift":{"syntax":"swift","highlights":[{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25}],"identifier":"01-01-04-code-0005.swift","fileType":"swift","type":"file","content":["import ComposableArchitecture","import XCTest","","@MainActor","final class ParentFeatureTests: XCTestCase {","    func testParentFeature() async {","        let store = TestStore(initialState: ParentFeature.State(child: ChildFeature.State(count: 0))) {","            ParentFeature()","        }","        ","        await store.send(\\.onAppear) {","            $0.child.count = 10","        }","        ","        await store.send(\\.child.incrementButtonTapped) {","            $0.child.count = 11","        }","        ","        await store.send(\\.child.resetTapped) {","            $0.child.count = 0","        }","        ","        await store.send(\\.child.decrementButtonTapped) {","            $0.child.count = -1","        }","    }","}"],"fileName":"ParentFeatureTests.swift"},"01-01-04-code-0001.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State: Equatable {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","        case onAppear","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            switch action {","            case .onAppear:","                return state.child","                    .updateNumber(with: 10)","                    .map(Action.child)","            default:","                return .none","            }","        }","    }","}","","extension ChildFeature.State {","    mutating func updateNumber(with count: Int) -> Effect<ChildFeature.Action> {","        self.count = count","        return .none","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","            .onAppear {","                store.send(.onAppear)","            }","        }","    }","}"],"type":"file","fileName":"ParentFeature.swift","syntax":"swift","highlights":[{"line":7}],"identifier":"01-01-04-code-0001.swift","fileType":"swift"},"doc://com.learnwithromain.learnwithromain/tutorials/RefineComposableArchitecture":{"title":"Refine the Composable Architecture","kind":"overview","type":"topic","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/RefineComposableArchitecture","abstract":[{"type":"text","text":"This interactive tutorial aims to provide best practices for building a project with TCA. It brings together information to help developers apply TCA principles effectively in their projects."}],"role":"overview","url":"\/tutorials\/refinecomposablearchitecture"},"01-01-01-code-0002.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        EmptyView()","    }","}",""],"type":"file","fileName":"ParentFeature.swift","syntax":"swift","highlights":[],"identifier":"01-01-01-code-0002.swift","fileType":"swift"},"https://pointfreeco.github.io/swift-composable-architecture/main/documentation/composablearchitecture/scope":{"identifier":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/scope","titleInlineContent":[{"type":"text","text":" Scope"}],"url":"https:\/\/pointfreeco.github.io\/swift-composable-architecture\/main\/documentation\/composablearchitecture\/scope","title":" Scope","type":"link"},"doc://com.learnwithromain.learnwithromain/tutorials/learnwithromain/ParentChildTutorial#Creating-a-parent-view-with-a-child-view":{"abstract":[{"type":"text","text":"Learn how to facilitate parent-child communication within TCA features. We will create both a parent and child feature and establish communication between them."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/com.learnwithromain.learnwithromain\/tutorials\/learnwithromain\/ParentChildTutorial#Creating-a-parent-view-with-a-child-view","title":"Creating a parent view with a child view","url":"\/tutorials\/learnwithromain\/parentchildtutorial#Creating-a-parent-view-with-a-child-view"},"01-01-03-video-0002.mov":{"type":"video","alt":null,"variants":[{"traits":["1x","light"],"url":"\/videos\/01-01-03-video-0002.mov"}],"poster":null,"identifier":"01-01-03-video-0002.mov"},"01-01-01-code-0001.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ChildFeature {","    @ObservableState","    struct State {","        var count: Int","    }","    ","    enum Action {","        case decrementButtonTapped","        case incrementButtonTapped","        case resetTapped","    }","    ","    var body: some ReducerOf<Self> {","        Reduce { state, action in","            switch action {","            case .incrementButtonTapped:","                state.count += 1","                return .none","            case .decrementButtonTapped:","                state.count -= 1","                return .none","            case .resetTapped:","                state.count = 0","                return .none","            }","        }","    }","}","","struct ChildView: View {","    let store: StoreOf<ChildFeature>","    ","    var body: some View {","        HStack {","            Button(\"-\") {","                store.send(.decrementButtonTapped)","            }","            .font(.largeTitle)","            .padding()","            .background(Color.black.opacity(0.1))","            .cornerRadius(10)","            Text(String(store.count))","                .font(.largeTitle)","                .padding()","                .background(Color.black.opacity(0.1))","                .cornerRadius(10)","                .onTapGesture {","                    store.send(.resetTapped)","                }","            Button(\"+\") {","                store.send(.incrementButtonTapped)","            }","            .font(.largeTitle)","            .padding()","            .background(Color.black.opacity(0.1))","            .cornerRadius(10)","        }","    }","}"],"type":"file","fileName":"ChildFeature.swift","syntax":"swift","highlights":[],"identifier":"01-01-01-code-0001.swift","fileType":"swift"},"01-01-02-code-0001.swift":{"type":"file","content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            switch action {","            case .child(.incrementButtonTapped):","                \/\/ We listen to the incrementButtonTapped child action","                return .none","            default:","                return .none","            }","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","        }","    }","}",""],"fileName":"ParentFeature.swift","syntax":"swift","highlights":[{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27}],"identifier":"01-01-02-code-0001.swift","fileType":"swift"},"01-01-04-code-0004.swift":{"fileType":"swift","type":"file","fileName":"ParentFeatureTests.swift","content":["import ComposableArchitecture","import XCTest","","@MainActor","final class ParentFeatureTests: XCTestCase {","    func testParentFeature() async {","        let store = TestStore(initialState: ParentFeature.State(child: ChildFeature.State(count: 0))) {","            ParentFeature()","        }","        ","        await store.send(\\.onAppear) {","            $0.child.count = 10","        }","    }","}"],"syntax":"swift","identifier":"01-01-04-code-0004.swift","highlights":[{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13}]},"01-01-03-code-0001.swift":{"content":["import ComposableArchitecture","import SwiftUI","","@Reducer","struct ParentFeature {","    @ObservableState","    struct State {","        var child: ChildFeature.State","    }","    ","    enum Action {","        case child(ChildFeature.Action)","    }","    ","    var body: some ReducerOf<Self> {","        Scope(state: \\.child, action: \\.child) {","            ChildFeature()","        }","        ","        Reduce { state, action in","            switch action {","            case .child(.decrementButtonTapped):","                guard state.child.count < 0 else { return .none }","                ","                return ChildFeature()","                    .reduce(","                        into: &state.child,","                        action: .resetTapped","                    )","                    .map(Action.child)","            default:","                return .none","            }","        }","    }","}","","struct ParentView: View {","    let store: StoreOf<ParentFeature>","    ","    var body: some View {","        VStack {","            ChildView(store: store.scope(","                state: \\.child,","                action: \\.child","            ))","        }","    }","}"],"type":"file","fileName":"ParentFeature.swift","syntax":"swift","highlights":[{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30}],"identifier":"01-01-03-code-0001.swift","fileType":"swift"},"01-01-01-image-0005.png":{"type":"image","alt":"iOS application showing a text view in the center displaying a 0 and two buttons positioned on each side of it, one for decrementing the count and one for incrementing.","variants":[{"traits":["1x","light"],"url":"\/images\/01-01-01-image-0005.png"}],"identifier":"01-01-01-image-0005.png"}}}